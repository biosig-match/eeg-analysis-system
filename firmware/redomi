#include <Arduino.h>
#include <BLEDevice.h>
#include <BLEServer.h>
#include <BLEUtils.h>
#include <BLE2902.h>
#include "zstd.h"
#include <string.h>
#include <math.h>

// --- 設定 (変更なし) ---
#define USE_DUMMY_DATA 1
#define NUM_EEG_CHANNELS 8
#define SAMPLE_RATE 256
#define SAMPLES_PER_PACKET (SAMPLE_RATE / 2)
#define TRIGGER_INTERVAL_SAMPLES (SAMPLE_RATE * 2)
#define TIMER_INTERVAL_US (1000000 / SAMPLE_RATE)

// --- BLE設定 (変更なし) ---
#define SERVICE_UUID           "6E400001-B5A3-F393-E0A9-E50E24DCCA9E"
#define CHARACTERISTIC_UUID_TX "6E400003-B5A3-F393-E0A9-E50E24DCCA9E"
#define CHARACTERISTIC_UUID_RX "6E400002-B5A3-F393-E0A9-E50E24DCCA9E"

// --- データ構造 (変更なし) ---
struct __attribute__((packed)) PacketHeader { char deviceId[18]; };
struct __attribute__((packed)) SensorData {
    uint16_t eeg[NUM_EEG_CHANNELS];
    float accel[3]; float gyro[3];
    uint8_t trigger;
    int8_t impedance[NUM_EEG_CHANNELS];
    uint32_t timestamp_us;
};

// --- グローバル変数 (変更なし) ---
PacketHeader packetHeader;
SensorData sensorDataBuffer[SAMPLES_PER_PACKET];
const size_t RAW_PAYLOAD_SIZE = sizeof(sensorDataBuffer);
const size_t TOTAL_RAW_SIZE = sizeof(PacketHeader) + RAW_PAYLOAD_SIZE;
BLEServer* pServer = nullptr;
BLECharacteristic* pTxCharacteristic = nullptr;
bool deviceConnected = false;
volatile bool canSendData = true;
volatile int sampleCounter = 0;
volatile bool sampleFlag = false;
hw_timer_t *timer = nullptr;
portMUX_TYPE timerMux = portMUX_INITIALIZER_UNLOCKED;
ZSTD_CCtx* cctx = NULL;
uint8_t* compressedBuffer = nullptr;
uint32_t samplesSinceLastTrigger = 0;

// --- BLEコールバック (変更なし) ---
class MyServerCallbacks: public BLEServerCallbacks {
    void onConnect(BLEServer* pServer) { deviceConnected = true; canSendData = true; Serial.println("✅ Client Connected!"); }
    void onDisconnect(BLEServer* pServer) { deviceConnected = false; Serial.println("❌ Client Disconnected. Restarting advertising..."); pServer->getAdvertising()->start(); }
};
class MyCharacteristicCallbacks: public BLECharacteristicCallbacks {
    void onWrite(BLECharacteristic *pCharacteristic) { canSendData = true; }
};

// --- データ生成 & タイマー割り込み (変更なし) ---
void generate_dummy_sensor_data(SensorData* data_ptr) {
    data_ptr->timestamp_us = micros();
    float time = data_ptr->timestamp_us / 1000000.0f;
    for (int ch = 0; ch < NUM_EEG_CHANNELS; ch++) {
        data_ptr->eeg[ch] = (uint16_t)(2048 + 150.0 * sin(2.0 * PI * 10.0 * time + ch));
    }
}
void IRAM_ATTR onTimer() {
    portENTER_CRITICAL_ISR(&timerMux);
    sampleFlag = true;
    portEXIT_CRITICAL_ISR(&timerMux);
}
void sendData() {
    canSendData = false;
    uint8_t* rawBuffer = new uint8_t[TOTAL_RAW_SIZE];
    memcpy(rawBuffer, &packetHeader, sizeof(PacketHeader));
    memcpy(rawBuffer + sizeof(PacketHeader), sensorDataBuffer, RAW_PAYLOAD_SIZE);
    size_t const compressedSize = ZSTD_compress(compressedBuffer, ZSTD_compressBound(TOTAL_RAW_SIZE), rawBuffer, TOTAL_RAW_SIZE, 1);
    delete[] rawBuffer;
    if (ZSTD_isError(compressedSize)) { canSendData = true; return; }
    uint32_t header = (uint32_t)compressedSize;
    size_t totalSize = sizeof(header) + compressedSize;
    uint8_t* sendBuffer = new uint8_t[totalSize];
    memcpy(sendBuffer, &header, sizeof(header));
    memcpy(sendBuffer + sizeof(header), compressedBuffer, compressedSize);
    const int max_chunk_size = 500;
    size_t bytes_sent = 0;
    while(bytes_sent < totalSize) {
        size_t chunk_size = std::min((size_t)max_chunk_size, totalSize - bytes_sent);
        pTxCharacteristic->setValue(sendBuffer + bytes_sent, chunk_size);
        pTxCharacteristic->notify();
        bytes_sent += chunk_size;
    }
    delete[] sendBuffer;
    sampleCounter = 0;
}

// --- セットアップ ---
void setup() {
    Serial.begin(115200);
    delay(2000); 
    Serial.println("\n--- [Checkpoint 1] Booting up... ---");

    uint8_t mac[6];
    esp_read_mac(mac, ESP_MAC_WIFI_STA);
    snprintf(packetHeader.deviceId, sizeof(packetHeader.deviceId), "%02X:%02X:%02X:%02X:%02X:%02X", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
    Serial.printf("[Checkpoint 2] Device ID (MAC): %s\n", packetHeader.deviceId);
    
    char bleName[32];
    snprintf(bleName, sizeof(bleName), "EEG-Device-%02X%02X", mac[4], mac[5]);
    BLEDevice::init(bleName);
    Serial.printf("[Checkpoint 3] BLE Advertising as: %s\n", bleName);

    pServer = BLEDevice::createServer();
    pServer->setCallbacks(new MyServerCallbacks());
    BLEService *pService = pServer->createService(SERVICE_UUID);
    pTxCharacteristic = pService->createCharacteristic(
        CHARACTERISTIC_UUID_TX, 
        BLECharacteristic::PROPERTY_NOTIFY
    );
    pTxCharacteristic->addDescriptor(new BLE2902());
    
    // ★★★ ここを修正しました ★★★
    // pServer->getService() を経由せず、pServiceから直接作成します。
    BLECharacteristic *pRxCharacteristic = pService->createCharacteristic(
        CHARACTERISTIC_UUID_RX, 
        BLECharacteristic::PROPERTY_WRITE_NR
    );
    pRxCharacteristic->setCallbacks(new MyCharacteristicCallbacks());

    pService->start();
    Serial.println("[Checkpoint 4] BLE Services created.");
    
    Serial.println("[Checkpoint 5] Allocating memory for compression...");
    compressedBuffer = new uint8_t[ZSTD_compressBound(TOTAL_RAW_SIZE)];
    if (!compressedBuffer) { Serial.println("FATAL: Failed to allocate compressedBuffer"); while(1); }
    cctx = ZSTD_createCCtx();
    if (!cctx) { Serial.println("FATAL: Failed to create ZSTD_CCtx"); while(1); }
    Serial.println("Memory allocation successful.");

    pServer->getAdvertising()->addServiceUUID(SERVICE_UUID);
    pServer->startAdvertising();
    Serial.println("[Checkpoint 6] BLE advertising started.");
    
    timer = timerBegin(0, 80, true);
    timerAttachInterrupt(timer, &onTimer, true);
    timerAlarmWrite(timer, TIMER_INTERVAL_US, true);
    timerAlarmEnable(timer);
    Serial.println("[Checkpoint 7] Timer started.");
    Serial.println("-------------------------");
    Serial.println("System Ready.");
}

// --- ループ (変更なし) ---
void loop() {
    if (sampleFlag) {
        portENTER_CRITICAL(&timerMux);
        sampleFlag = false;
        portEXIT_CRITICAL(&timerMux);
        if (sampleCounter < SAMPLES_PER_PACKET) {
            if (samplesSinceLastTrigger >= TRIGGER_INTERVAL_SAMPLES) {
                sensorDataBuffer[sampleCounter].trigger = 1;
                samplesSinceLastTrigger = 0;
            } else {
                sensorDataBuffer[sampleCounter].trigger = 0;
            }
            samplesSinceLastTrigger++;
            #if USE_DUMMY_DATA
                generate_dummy_sensor_data(&sensorDataBuffer[sampleCounter]);
            #else
                // read_real_sensor_data(&sensorDataBuffer[sampleCounter]);
            #endif
            sampleCounter++;
        }
    }
    if (sampleCounter >= SAMPLES_PER_PACKET && deviceConnected && canSendData) {
        sendData();
    }
}